import os
import re 
import numpy as np 
from binascii import unhexlify
import Dilithium_functions as dilithium

solver_name = input("Enter solver's name (between 'scipy' and 'lpsolve') ")
if solver_name != "scipy" and solver_name != "lpsolve":
    print("Wrong solver's name, reverting to 'scipy'")
    SOLVER = "scipy"
else:
    SOLVER = solver_name

if SOLVER == "scipy":
    from scipy.optimize import linprog
elif SOLVER == "lpsolve":
    try:
        import lpsolve55 as lps
    except ModuleNotFoundError:
        SOLVER = "scipy"
        print("Module lpsolve55 not found, using scipy instead")
        from scipy.optimize import linprog
        
        
class Lp:
    def __init__(self, param, integers = True):
        if isinstance(param, int):
            self._initialize_from_integer(param, integers = integers)
        elif isinstance(param, bytes):  # Initialize based on list
            self._initialize_from_file(param)
        else:
            raise ValueError("Unsupported parameter type")    

    def _initialize_from_integer(self, len, integers = True):
        self.lp = lps.lpsolve(b'make_lp', 0, len)
        for i in range(len):
            col = i + 1
            self.set_col_name(col, f's{i}'.encode())
            self.set_lowbo(col, -dilithium.ETA)
            self.set_upbo(col, +dilithium.ETA)
            if integers:
                self.set_int(col, True)

    def _initialize_from_file(self, file_name):
        self.lp = lps.lpsolve(b'read_LP', file_name)

    def __getattr__(self, attr):
        return lambda *args: lps.lpsolve(attr.encode(), self.lp, *args)
        
            
def free_all_lps():
    """
    This function frees all the lpsolve lp open 
                
    Parameters
    ----------
    
    Returns
    ----------
    
    """
    lps_to_free = lps.lpsolve(b"print_handle")
    print("Freeing LPs: ",lps_to_free)
    if isinstance(lps_to_free, int):
        lps.lpsolve(b"free_lp", lps_to_free)
    else:
        for lp_to_free in lps_to_free:
            lps.lpsolve(b"free_lp", lp_to_free)    
    

def print_np_file_infos(npz_file_name):
    """
    This function reads an .npz file name prints its infos and return the corresponding np object 
                
    Parameters
    ----------
    npz_file_name                (str): Input lp file name.

    Returns
    ----------
    loaded_array (np object of arrays): Object containing the arrays in the npz_file_name
    """
    
    loaded_array = np.load(npz_file_name)
    
    print(f"Loading: {npz_file_name}")
    for element in loaded_array.files:
        print(f"  >>> '{element}': {loaded_array[element].shape}")
    return loaded_array


def parse_ineq_lpfile(lps_file_name):
    """
    This function reads an .lp file specified by the name lp_file_name, 
    and returns the corresponding inequalities specified in it. 
    DISCLAIMER: This function only works for files generated by lpsolve for python
                and produced by the relevant script used for the attack in: 
                
    Parameters
    ----------
    lp_file_name           (str): Input lp file name.

    Returns
    ----------
    signs_file_lines (1-D array): Inequalities of the lp file on x where each 
                                  line is of the form:
                                    - "c0 * x0 + c1 * x1 + ... + cn * xn >= bi" or
                                    - "c0 * x0 + c1 * x1 + ... + cn * xn <= bi"
    """
    signs_file_lines = []
    
    with open(lps_file_name, "r") as f:
        string = ""
        # Discard 2 first lines as not relevant
        f.readline()
        f.readline()
        
        # The break-line char will be used to delimit the end of inequalities
        delimiter = f.readline()
        
        # Discard comment 
        f.readline()
        
        # We start parsing the inequalities untill we reach our delimiter
        line = f.readline()
        while line != delimiter:
            # lpsolve breaks long inequalities into several lines (usually three)
            # Here, we reconstruct them into one line untill reaching the end of inequality char ";"
            buff = line[:-1]
            string += buff
            if buff[-1] == ";":
                signs_file_lines.append(string)
                string = ""
            line = f.readline()
    return signs_file_lines


def split_ineq(expression):
    """
    This function splits an inequality of the form:
        - "c0 * x0 + c1 * x1 + ... + cn * xn >= bi
        - "c0 * x0 + c1 * x1 + ... + cn * xn <= bi"
    into three elements "c0 * x0 + c1 * x1 + ... + cn * xn", ">=" or "<=", "bi".
    Parameters
    ----------
    expression (str): Inequalities of the lp file on x as specified.
    
    Returns 
    ----------
    constraint (str): "c0 * x0 + c1 * x1 + ... + cn * xn"
    ineq_type  (str): ">=" or "<="
    bound      (str): "bi"
    """
    return re.split(r'\s*(>=|<=)\s*', expression)


def parse_left_part_ineq(left_part, inverse_ = False):
    """
    This function reads a string inequality on x and returns its array form
    DISCLAIMER: This function only works for files generated by lpsolve for python
                and produced by the relevant script used for the attack in: 
                
    Parameters
    ----------
    left_part (str) : Inequality line of the form "c0 * x0 + c1 * x1 + ... + cn * xn"
    inverse_  (bool): If the inequality is of the type "<", default, or ">", inverted

    Returns
    ----------
    a_   (1-D array): Array representing the inequality, [c0, c1, ... , cn]
    """
    def split_left_string(expression):
        converter = lambda x: -1 if x == "-" else 1
        
        signs, indices = re.split(r'([-+])', expression)[1:]
        signs = converter(signs)
        return (int(indices[1:]), signs)
    
    # We get an array with ["c0x0", "c1x1", ... , "cnxn"]
    left_part_split =  left_part.split(" ")
    
    a_ = [0 for i in range(dilithium.N)]
    
    for element in left_part_split:
        ind_, val_ = split_left_string(element)
        if inverse_ == True:
            a_[ind_] = -val_
        else:
            a_[ind_] = val_
    return a_ 


def parse_right_part_ineq(right_part, inverse_ = False):
    """
    This function reads a string "number;" and return the int number.
    Flips the sign if necessary.
                
    Parameters
    ----------
    right_part (str): String containing a number of the form "number;"
    inverse_  (bool): If the inequality is of the type "<", default, or ">", inverted

    Returns
    ----------
    number     (int): Integer of number. 
    """
    if inverse_ == True:
        return -int(right_part[:-1]) 
    return int(right_part[:-1]) 


def lpfile_to_scipy(lp_file_name, default_ = "<"):
    """
    This function reads an .lp file specified by the name lp_file_name, 
    and returns the corresponding LP instance in matrix/vector form 
    
    Parameters
    ----------
    lp_file_name (str): Input lp file name.                    
    default_     (str): Inequality type, default to "<"

    Returns
    ----------
    A      (2-D array): Inequality constraint matrix, each row specifies 
                        the coefficients of a linear inequality constraint on x.
    b      (1-D array): The inequality constraint vector, each element represents 
                        an upper bound on the corresponding value of A @ x.
    c      (1-D array): The coefficients of the linear objective function to be minimized.
    bounds (2-D array): A sequence of (min, max) pairs for each element in x.
    """
    
    signs_file_lines = parse_ineq_lpfile(lp_file_name)
    
    len_ = len(signs_file_lines)

    A = [0 for _ in range(len_)]
    b = [0 for _ in range(len_)]
    c = [0 for _ in range(dilithium.N)]
    
    bool_ = False
    for line_ in range(len_):
        left_, ineq_type, right_ = split_ineq(signs_file_lines[line_])
        if ineq_type[:-1] != default_:
            bool_ = True
        else:
            bool_ = False
            
        A_ = parse_left_part_ineq(left_, inverse_ = bool_)
        A[line_] = A_
        
        b_ = parse_right_part_ineq(right_, inverse_ = bool_)
        b[line_] = b_
        
    return A, b, c
    
    
def open_pk_sk(nb_keys = 1, keys_file_name = f"../KAT/PQCsignKAT_Dilithium{dilithium.MODE}.rsp"):
    """
    This function reads nb_keys dilithium keys from the file keys_file_name. 
                
    Parameters
    ----------
    nb_keys        (int): Number of keys to read from the keys file.
    keys_file_name (str): Name of the file containing the keys to read. 

    Returns
    ----------
    PK   (dict[int]:str): Dict containg in the index i, the public key i read from the file. 
    SK   (dict[int]:str): Dict containg in the index i, the secret key i read from the file. 
    """
    
    nb_lines_per_KAT = 8
    index_of_pk      = 4
    index_of_sk      = 5
    offset           = 0
    SK = {}
    PK = {}
    
    with open(f"{os.getcwd()}/{keys_file_name}", "r") as file:
        # We discard the first flag for the version of Dilithium as well as the first and last \n
        lines = file.read().splitlines()[2:-1]

        # Raise an error when there is not enough keys in the KAT file
        if len(lines) < nb_keys*8:
            raise ValueError("Not enough keys in the KAT file")

        for key_ in range(nb_keys):
            key_index = int(lines[offset + 0].split("=")[-1])

            pk = lines[offset + index_of_pk].split("=")[-1][1:]
            if len(pk) != 2*dilithium.CRYPTO_PUBLICKEYBYTES:
                raise ValueError(f"Wrong len of pk in the Kat file for key #{key_index}")

            sk = lines[offset + index_of_sk].split("=")[-1][1:]
            if len(sk) != 2*dilithium.CRYPTO_SECRETKEYBYTES:
                raise ValueError(f"Wrong len of sk in the Kat file for key #{key_index}")
                 
            PK[key_index] = pk
            SK[key_index] = sk
            offset += 1
            offset += nb_lines_per_KAT

    return PK, SK


def open_signs(key, nb_Signs = 100000, signs_loc = "../Signs"):
    nb_lines_per_Sign = 3
    cpt               = 0
    path_file  = f"{signs_loc}/Dilithium{dilithium.MODE}/{nb_Signs}SignsKAT_key{key}.rsp"
    Signs = {}
    
    with open(path_file, "r") as file:
        for line in file:
            line = line[:-1]
            if cpt%(nb_lines_per_Sign + 1) == 0:
                sign_index = int(line.split("=")[-1])
                Signs[sign_index] = {}
            else:
                if cpt%(nb_lines_per_Sign + 1) == 1:
                    sign = line.split("=")[-1][1:]
                    Signs[sign_index]["sign"] = sign
                else:
                    if cpt%(nb_lines_per_Sign + 1) == 2:
                        msg = line.split("=")[-1][1:]
                        Signs[sign_index]["msg"] = msg
            cpt += 1
    return Signs


def open_signs_filtered(key, nb_Signs = 100000, signs_loc = "../Signs_filtered"):
    cpt               = 0
    path_file  = f"{signs_loc}/Dilithium{dilithium.MODE}/{nb_Signs}SignsKAT_key{key}_filtered.rsp"
    Signs = {}
        
    with open(path_file, "r") as file:
        for line in file:
            sign_index = int(line.split("=")[-1])
            Signs[sign_index] = {}

            line = file.readline()
            sign = line.split("=")[-1][1:]
            Signs[sign_index]["sign"] = sign[:-1]
            
            line = file.readline()
            msg = line.split("=")[-1][1:]
            Signs[sign_index]["msg"] = msg[:-1]

            line = file.readline()
            neg = line.split("=")[-1][1:]
            Signs[sign_index]["neg"] = int(neg[:-1])

            line = file.readline()
            index = line.split("=")[-1][1:]
            Signs[sign_index]["index"] = int(index[:-1])

            line = file.readline()
            cpt+=1
    return Signs


def mult_xi(poly, degree = dilithium.N, i = 0):
    """
    This function multiplies a polynomial poly (in Z_Q[x]/(x^N + 1) ) by x^i.
    Parameters
    ----------
    poly (1-D array): Polynomial from the ring Z_Q[x]/(x^N + 1) represented as a list of its coefficients.
    
    Returns 
    ----------
    poly (1-D array): poly* x^i
    """
    poly_ = np.array(poly)
    left_part  = -poly_[degree - i:]
    right_part = poly_[:degree - i]
    return list(np.concatenate((left_part, right_part), axis = 0))
